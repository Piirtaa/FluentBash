our general approach is to take a datagram (represents the state of the operation or current work)
pipe it to some process which will further mutate the datagram, and possibly kick off some processes
which themselves will be referenced in the datagram.

datagram
	data
		bash vars
	files
		list of files
	processes
		pids
	conditions (bash functions that can be evaluated)
		canInit condition - if true, initialize() runs
		canRun - if true, run() runs
		canStop - if true, stop() runs
		canDispose - if true, dispose() runs
	state
		lifecycle:  notRun -> initializing -> running -> stopping -> disposing -> stopped
			can only change state in one direction (towards being stopped)
	strategies
		initialize()		
		run()
		stop()
		dispose()
		
format is
	"_SECTION_"{section name}_{lineCount} (eg. data, files, processes, conditions, strategies, state)		
	
eg.
	_SECTION_data_2
		VAR1=
		VAR2=
	_SECTION_files_0
	_SECTION_processes_0
	_SECTION_state_1
		notRun|initializing|running|stopping|disposing|stopped
	_SECTION_strategies_8  
	_STRATEGY_initialize_3
		function code1
		function code2
		function code3
	_STRATEGY_run_3
		function code1
		function code2
		function code3
	_SECTION_conditions_0

this datagram typically gets stored as a file and loaded as a file			